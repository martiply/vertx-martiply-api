package com.martiply.api

import java.util.concurrent.TimeUnit

import com.github.jasync.sql.db.general.ArrayRowData
import com.github.jasync.sql.db.mysql.MySQLConnection
import com.github.jasync.sql.db.mysql.pool.MySQLConnectionFactory
import com.github.jasync.sql.db.pool.{ConnectionPool, PoolConfiguration}
import com.github.jasync.sql.db.{Configuration, Connection, SSLConfiguration}
import com.martiply.api.model._
import com.martiply.model.interfaces.IItem.{Category, Condition, IdType}
import com.martiply.table._
import io.vertx.core.json.JsonObject

import scala.collection.JavaConverters._
import scala.compat.java8.FutureConverters
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future

object Repository {
  def apply(mySqlConf: JsonObject): Repository = {
    val con = buildClient(mySqlConf)
    new Repository(con, mySqlConf.getJsonObject("query"))
  }

  def buildClient(mySqlConf: JsonObject): ConnectionPool[MySQLConnection] = {
    val pool = mySqlConf.getJsonObject("pool")
    val poolConfiguration = new PoolConfiguration(
      pool.getInteger("maxObjects"),
      TimeUnit.MINUTES.toMillis(pool.getLong("maxIdleMin")),
      pool.getInteger("maxQueueSize"),
      TimeUnit.SECONDS.toMillis(pool.getLong("validationIntervalSec"))
    )
    new ConnectionPool(
      new MySQLConnectionFactory(new Configuration(
        mySqlConf.getString("username"),
        mySqlConf.getString("host"),
        mySqlConf.getInteger("port"),
        mySqlConf.getString("password"),
        mySqlConf.getString("database"),
        new SSLConfiguration()
      )), poolConfiguration)
  }

  def qsSearchArea(limit: Int): String = {
    s"""
       |		SELECT * FROM (SELECT ${TableStore.STORE_ID_F}, ${TableStore.NAME_F}, astext(${TableStore.GEO_F}) as ${TableStore.GEO}, ${TableStore.CURRENCY_F},
       |    ${TableStore.EMAIL_F}, ${TableStore.ZIP_F}, ${TableStore.ADDRESS_F}, ${TableStore.CITY_F}, ${TableStore.PHONE_F}, ${TableStore.OPEN_F}, ${TableStore.CLOSE_F},
       |    ${TableStore.STORY_F}, ${TableStore.TZ_F},
       |			standard_id, ${TableStandard.OWNER_ID_F}, ${TableStandard.ID_TYPE_F}, ${TableStandard.GTIN_F}, ${TableStandard.ID_CUSTOM_F}, ${TableStandard.BRAND_F},
       |      standard_name, ${TableStandard.COND_F}, ${TableStandard.CATEGORY_F}, ${TableStandard.PRICE_F}, ${TableStandard.DESCRIPTION_F}, ${TableStandard.URL_F},
       |      ${TableStandard.HIT_F}, sale_id, ${TableStandardSale.SALE_PRICE_F}, ${TableStandardSale.SALE_START_F}, ${TableStandardSale.SALE_END_F}, urli, urls,
       |      score,
       |
       |      ST_Distance_Sphere(point(?, ?), geo) as distance_in_meters FROM ${TableStore.TABLE_NAME} AS ${TableStore.TABLE_NAME}
       |
       |			JOIN ${TableInventory.TABLE_NAME} ON ${TableInventory.STORE_ID_F} = ${TableStore.STORE_ID_F}
       |			JOIN (SELECT ${TableStandard.ID_F} AS standard_id, ${TableStandard.OWNER_ID_F}, ${TableStandard.ID_TYPE_F}, ${TableStandard.GTIN_F},
       |      ${TableStandard.ID_CUSTOM_F}, ${TableStandard.BRAND_F}, ${TableStandard.NAME_F} AS standard_name, ${TableStandard.COND_F}, ${TableStandard.CATEGORY_F},
       |      ${TableStandard.PRICE_F}, ${TableStandard.DESCRIPTION_F}, ${TableStandard.URL_F}, ${TableStandard.HIT_F},
       |      MATCH (${TableStandard.NAME_F}, ${TableStandard.CATEGORY_F}, ${TableStandard.BRAND_F}) AGAINST(?) as score FROM ${TableStandard.TABLE_NAME}
       |      WHERE MATCH (${TableStandard.NAME_F}, ${TableStandard.CATEGORY_F}, ${TableStandard.BRAND_F}) AGAINST(?))  AS standard ON ${TableInventory.ID_F} = standard_id
       |
       |			LEFT JOIN (SELECT ${TableStandardSale.ID_F} as sale_id, ${TableStandardSale.SALE_PRICE_F}, ${TableStandardSale.SALE_START_F}, ${TableStandardSale.SALE_END_F}
       |      FROM ${TableStandardSale.TABLE_NAME}
       |			WHERE ${TableStandardSale.SALE_START_F} < ? AND ${TableStandardSale.SALE_END_F} > ? ) AS ${TableStandardSale.TABLE_NAME}
       |			ON standard_id = sale_id
       |			LEFT JOIN (SELECT ${TableImgStd.ID_F}, GROUP_CONCAT(${TableImgStd.URL_F}) urli FROM ${TableImgStd.TABLE_NAME} GROUP BY ${TableImgStd.ID_F}) as ${TableImgStd.TABLE_NAME} ON ${TableImgStd.ID_F} = standard_id
       |			LEFT JOIN (SELECT ${TableImgStore.ID_F}, GROUP_CONCAT( ${TableImgStore.URL_F}) urls FROM ${TableImgStore.TABLE_NAME} GROUP BY ${TableImgStore.ID_F}) as ${TableImgStore.TABLE_NAME} ON ${TableImgStore.ID_F} = ${TableStore.STORE_ID_F}
       |			WHERE ST_Within(geo, ST_Buffer(POINT(?, ?), 0.020)) ORDER BY distance_in_meters, score
       |			) AS d
       """.stripMargin
  }

  val searchStore: String =
    s"""
       |SELECT ${TableStandard.TABLE_NAME}.*, ${TableStandardSale.TABLE_NAME}.*, ${TableStore.CURRENCY_F}, CONCAT(urli) AS urli,
       |MATCH (${TableStandard.NAME_F}, ${TableStandard.CATEGORY_F}, ${TableStandard.BRAND_F}) AGAINST (?) as score FROM ${TableInventory.TABLE_NAME}
       |JOIN ${TableStore.TABLE_NAME} ON ${TableInventory.STORE_ID_F} = ${TableStore.STORE_ID_F}
       |JOIN ${TableStandard.TABLE_NAME} ON ${TableInventory.ID_F} = ${TableStandard.ID_F}
       |LEFT JOIN (SELECT ${TableStandardSale.ID_F} as sale_id, ${TableStandardSale.SALE_PRICE_F}, ${TableStandardSale.SALE_START_F}, ${TableStandardSale.SALE_END_F} FROM ${TableStandardSale.TABLE_NAME} WHERE ${TableStandardSale.SALE_START_F} < ? AND ${TableStandardSale.SALE_END_F} > ?) AS standard_sale ON ${TableStandard.ID_F} = sale_id
       |LEFT JOIN (SELECT ${TableImgStd.ID}, GROUP_CONCAT(${TableImgStd.URL_F}) urli FROM ${TableImgStd.TABLE_NAME} GROUP BY ${TableImgStd.ID}) AS ${TableImgStd.TABLE_NAME} ON ${TableInventory.ID_F} = ${TableImgStd.ID_F}
       |WHERE ${TableInventory.STORE_ID_F} = ?
       |AND MATCH (${TableStandard.NAME_F}, ${TableStandard.CATEGORY_F}, ${TableStandard.BRAND_F}) AGAINST (?) ORDER BY score DESC LIMIT %d
     """.stripMargin

  def qsSearchStoreKeyword(limit: Int): String =
    s"""
       |SELECT ${TableStandard.TABLE_NAME}.*, ${TableStandardSale.TABLE_NAME}.*, ${TableStore.CURRENCY_F}, CONCAT(urli) AS urli,
       |MATCH (${TableStandard.NAME_F}, ${TableStandard.CATEGORY_F}, ${TableStandard.BRAND_F}) AGAINST (?) as score FROM ${TableInventory.TABLE_NAME}
       |JOIN ${TableStore.TABLE_NAME} ON ${TableInventory.STORE_ID_F} = ${TableStore.STORE_ID_F}
       |JOIN ${TableStandard.TABLE_NAME} ON ${TableInventory.ID_F} = ${TableStandard.ID_F}
       |LEFT JOIN (SELECT ${TableStandardSale.ID_F} as sale_id, ${TableStandardSale.SALE_PRICE_F}, ${TableStandardSale.SALE_START_F}, ${TableStandardSale.SALE_END_F} FROM ${TableStandardSale.TABLE_NAME} WHERE ${TableStandardSale.SALE_START_F} < ? AND ${TableStandardSale.SALE_END_F} > ?) AS standard_sale ON ${TableStandard.ID_F} = sale_id
       |LEFT JOIN (SELECT ${TableImgStd.ID}, GROUP_CONCAT(${TableImgStd.URL_F}) urli FROM ${TableImgStd.TABLE_NAME} GROUP BY ${TableImgStd.ID}) AS ${TableImgStd.TABLE_NAME} ON ${TableInventory.ID_F} = ${TableImgStd.ID_F}
       |WHERE ${TableInventory.STORE_ID_F} = ?
       |AND MATCH (${TableStandard.NAME_F}, ${TableStandard.CATEGORY_F}, ${TableStandard.BRAND_F}) AGAINST (?) ORDER BY score DESC LIMIT $limit
     """.stripMargin

  def qsSearchStoreRandom(limit: Int): String =
    s"""
       |SELECT ${TableStandard.TABLE_NAME}.*, ${TableStandardSale.TABLE_NAME}.*, ${TableStore.CURRENCY_F}, CONCAT(urli) AS urli FROM ${TableInventory.TABLE_NAME}
       |JOIN ${TableStore.TABLE_NAME} ON ${TableInventory.STORE_ID_F} = ${TableStore.STORE_ID_F}
       |JOIN ${TableStandard.TABLE_NAME} ON ${TableInventory.ID_F} = ${TableStandard.ID_F}
       |LEFT JOIN (SELECT ${TableStandardSale.ID_F} as sale_id, ${TableStandardSale.SALE_PRICE_F}, ${TableStandardSale.SALE_START_F}, ${TableStandardSale.SALE_END_F} FROM ${TableStandardSale.TABLE_NAME} WHERE ${TableStandardSale.SALE_START_F} < ? AND ${TableStandardSale.SALE_END_F} > ?) AS standard_sale ON ${TableStandard.ID_F} = sale_id
       |LEFT JOIN (SELECT ${TableImgStd.ID}, GROUP_CONCAT(${TableImgStd.URL_F}) urli FROM ${TableImgStd.TABLE_NAME} GROUP BY ${TableImgStd.ID}) AS ${TableImgStd.TABLE_NAME} ON ${TableInventory.ID_F} = ${TableImgStd.ID_F}
       |WHERE ${TableInventory.STORE_ID_F} = ?
       |ORDER BY RAND() LIMIT $limit
     """.stripMargin

  def qsGetStores(limit: Int): String =
    s"""
       |SELECT ${TableStore.STORE_ID}, ${TableStore.NAME}, astext(${TableStore.GEO}) as ${TableStore.GEO}, ${TableStore.CURRENCY},
       | ${TableStore.EMAIL}, ${TableStore.ZIP}, ${TableStore.ADDRESS}, ${TableStore.CITY}, ${TableStore.PHONE}, ${TableStore.OPEN}, ${TableStore.CLOSE},
       | ${TableStore.STORY}, ${TableStore.TZ}, urls, distance_in_meters
       | FROM (SELECT ${TableStore.TABLE_NAME}.*, CONCAT(urls) AS urls,
       | ST_Distance_Sphere(point(?, ?), geo) as distance_in_meters FROM ${TableStore.TABLE_NAME} AS ${TableStore.TABLE_NAME}
       | LEFT JOIN (SELECT ${TableImgStore.ID}, GROUP_CONCAT(${TableImgStore.URL}) urls FROM ${TableImgStore.TABLE_NAME} GROUP BY ${TableImgStore.ID_F}) as ${TableImgStore.TABLE_NAME} ON ${TableImgStore.ID_F} = ${TableStore.STORE_ID_F}) AS ${TableImgStore.TABLE_NAME}
       | WHERE ST_Within(geo, ST_Buffer(POINT(?, ?), 0.020)) ORDER BY distance_in_meters LIMIT $limit
     """.stripMargin

  def qsGetStore(): String =
    s"""
       |SELECT ${TableStore.STORE_ID}, ${TableStore.NAME}, astext(${TableStore.GEO}) as ${TableStore.GEO}, ${TableStore.CURRENCY},
       |${TableStore.EMAIL}, ${TableStore.ZIP}, ${TableStore.ADDRESS}, ${TableStore.CITY}, ${TableStore.PHONE}, ${TableStore.OPEN}, ${TableStore.CLOSE},
       |${TableStore.STORY}, ${TableStore.TZ}, urls FROM store
       |LEFT JOIN (SELECT ${TableImgStore.ID} AS store_id, GROUP_CONCAT(${TableImgStore.URL}) urls FROM ${TableImgStore.TABLE_NAME} GROUP BY ${TableImgStore.ID_F})  AS ${TableImgStore.TABLE_NAME} ON ${TableImgStore.TABLE_NAME}.store_id = ${TableStore.STORE_ID_F}
       |WHERE storeId = ?
     """.stripMargin

  def saleFrom(r: ArrayRowData, saleIdAlias: String = "sale_id"): Option[Sale] = {
    if (r.get(saleIdAlias) != null) {
      Some(Sale(r.get(saleIdAlias).asInstanceOf[String], r.get(TableStandardSale.SALE_PRICE).asInstanceOf[Float], r.get(TableStandardSale.SALE_START).asInstanceOf[Long], r.get(TableStandardSale.SALE_END).asInstanceOf[Long]))
    } else {
      None
    }
  }

  def imgFrom(r: ArrayRowData, imgAlias: String): Img = Img(Option(r.get(imgAlias).asInstanceOf[String]).getOrElse("").split(",").toList)

  def itemFrom(r: ArrayRowData, sale: Option[Sale], img: Img,  standardIdAlias: String, standardNameAlias: String): Item =
    Item(r.get(standardIdAlias).asInstanceOf[String], r.get(TableStandard.OWNER_ID).asInstanceOf[Int], Item.findIdType(r.get(TableStandard.ID_TYPE).asInstanceOf[String]).getOrElse(IdType.custom),
      r.get(TableStandard.ID_CUSTOM).asInstanceOf[String], r.get(TableStandard.GTIN).asInstanceOf[String], r.get(standardNameAlias).asInstanceOf[String], Item.findCategory(r.get(TableStandard.CATEGORY).asInstanceOf[String]).getOrElse(Category.product),
      r.get(TableStandard.BRAND).asInstanceOf[String], Item.findCondition(r.get(TableStandard.COND).asInstanceOf[String]).getOrElse(Condition.NEW), r.get(TableStandard.DESCRIPTION).asInstanceOf[String], r.get(TableStandard.URL).asInstanceOf[String],
      img, r.get(TableStandard.HIT).asInstanceOf[Int], sale, None)

  def storeFrom(r: ArrayRowData, img: Img, distance: Option[Double], geoAlias: String = "geo"): Store ={
    val lnglat = r.get(geoAlias).asInstanceOf[String]
    Store(r.get(TableStore.STORE_ID).asInstanceOf[Int], r.get(TableStore.NAME).asInstanceOf[String], r.get(TableStore.ZIP).asInstanceOf[String], r.get(TableStore.ADDRESS).asInstanceOf[String],
      r.get(TableStore.EMAIL).asInstanceOf[String], r.get(TableStore.PHONE).asInstanceOf[String], lnglat.head, lnglat(1),
      r.get(TableStore.OPEN).asInstanceOf[String], r.get(TableStore.CLOSE).asInstanceOf[String], distance, r.get(TableStore.STORY).asInstanceOf[String],
      r.get(TableStore.CURRENCY).asInstanceOf[String], r.get(TableStore.TZ).asInstanceOf[Byte].toString.toInt, r.get(TableStore.CITY).asInstanceOf[String], img)
  }

}

class Repository(client: ConnectionPool[MySQLConnection], queryConf: JsonObject) {
  val limit: Integer = queryConf.getInteger("limit")

  def terminate(): Future[Connection] = FutureConverters.toScala(client.disconnect())

  def testConnection(): Future[Repository] =  {
    for {
      fcon <- FutureConverters.toScala(client.connect())
      fque <- FutureConverters.toScala(fcon.sendQuery("SELECT 'hello'"))
      ffin <-
        if (fque.getRows.get(0).get(0).toString.equals("hello")){
          Future.successful(this)
        } else {
          Future.failed(new Throwable("Test query failed"))
        }
    } yield ffin
  }

  def search(kwd: String, lat: Double, lng: Double, legitSaleTs: Long, category: Option[Category]): Future[MtpResponse[IPP]] = {
    val params = Seq(
      lng,
      lat,
      kwd,
      kwd,
      legitSaleTs,
      legitSaleTs,
      lng,
      lat
    )
    val sql = Repository.qsSearchArea(limit)
    for {
      fque <- FutureConverters.toScala(client.sendPreparedStatement(sql, params.asJava))
      fpar <- Future {
        val res = fque.getRows.stream().toArray().map(_.asInstanceOf[ArrayRowData]).map(r => {
          val imgItem  = Repository.imgFrom(r, "urli")
          val sale     = Repository.saleFrom(r)
          val item     = Repository.itemFrom(r, sale, imgItem, "standard_id", "standard_name")
          val imgStore = Repository.imgFrom(r, "urls")
          val distance = Some(r.get("distance_in_meters").asInstanceOf[Double])
          val store    = Repository.storeFrom(r, imgStore, distance)
          IPP(item, store)
        }).toList
        MtpResponse.success(res)
      }
    } yield fpar

  }

  def getStores(lat: Double, lng: Double): Future[MtpResponse[Store]] = {
    val params = Seq(lng, lat, lng, lat)
    val sql    = Repository.qsGetStores(limit)
    for {
      fque <- FutureConverters.toScala(client.sendPreparedStatement(sql, params.asJava))
      fpar <- Future {
        val res = fque.getRows.stream().toArray().map(_.asInstanceOf[ArrayRowData]).map(r => {
          val imgStores = Repository.imgFrom(r, "urls")
          val distance  = Some(r.get("distance_in_meters").asInstanceOf[Double])
          Repository.storeFrom(r, imgStores, distance)
        }).toList
        MtpResponse.success(res)
      }
    } yield fpar
  }

  def getStore(storeId: Int): Future[MtpResponse[Store]] = {
    val params = Seq(storeId)
    val sql    = Repository.qsGetStore()
    for {
      fque <- FutureConverters.toScala(client.sendPreparedStatement(sql, params.asJava))
      fpar <- Future {
        val res = fque.getRows.stream().toArray().map(_.asInstanceOf[ArrayRowData]).map(r => {
          val imgStores = Repository.imgFrom(r, "urls")
          val distance  = None
          Repository.storeFrom(r, imgStores, distance)
        }).toList
        MtpResponse.success(res)
      }
    } yield fpar

  }


  def searchStoreKeyword(kwd: String, storeId: Int, legitSaleTs: Long): Future[MtpResponse[Item]] = {
    val params = Seq(kwd, legitSaleTs, legitSaleTs, storeId, kwd)
    val sql    = Repository.qsSearchStoreKeyword(limit)
    searchStoreFut(sql, params)
  }

  def searchStoreRandom(storeId: Int, legitSaleTs: Long): Future[MtpResponse[Item]] = {
    val params = Seq(legitSaleTs, legitSaleTs, storeId)
    val sql    = Repository.qsSearchStoreRandom(limit)
    searchStoreFut(sql, params)
  }

  private def searchStoreFut(sql: String, params: Seq[Any]): Future[MtpResponse[Item]] = {
    for {
      fque <- FutureConverters.toScala(client.sendPreparedStatement(sql, params.asJava))
      fpar <- Future {
        val res = fque.getRows.stream().toArray().map(_.asInstanceOf[ArrayRowData]).map(r => {
          val imgItem = Repository.imgFrom(r, "urli")
          val sale    = Repository.saleFrom(r)
          Repository.itemFrom(r, sale, imgItem, TableStandard.ID, TableStandard.NAME)
        }).toList
        MtpResponse.success(res)
      }
    } yield fpar
  }





}